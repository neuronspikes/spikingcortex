using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SpikingNeurons
{
    /// <summary>
    /// Neuron Fabric
    /// (CC) Stéphane Denis
    /// 
    /// Fabric is the finest grain of cortex architecture configuration.
    /// It defines its affinities, rates and treshold of a group of neurons.
    /// 
    ///<!-- Creative Commons License -->
    ///<a href="http://creativecommons.org/licenses/GPL/2.0/">
    ///<img alt="CC-GNU GPL" border="0" src="http://creativecommons.org/images/public/cc-GPL-a.png" /></a><br />
    ///This software is licensed under the <a href="http://creativecommons.org/licenses/GPL/2.0/">CC-GNU GPL</a> version 2.0 or later.
    ///<!-- /Creative Commons License -->
    /// </summary>
    public class Fabric : Fibre
    {
        /// <summary>
        /// Default constructor. 
        /// Treshold=1
        /// SpikeEffect=0 : Complete reset
        /// Leak=0.9 : little leak
        /// 
        /// No size constraint >> Be careful, your computer can die!
        /// </summary>
        /// <param name="name">Unique name of this neuron fabric</param>
        public Fabric(string name)
        {
            this.name = name;
            neurons = new List<SpikingNeuron>();
            inputFibres = new Dictionary<string, InputFibre>();
            inputs = new List<SpikingNeuron>();
            outputs = new List<SpikingNeuron>();


            treshold = 1;
            spikeEffect = 0; // spikes do reset neuron state
            leak = 0.9; // neurons have little leak
        }

        private static int notLearning = 0;

        public static int NotLearning
        {
            get { return Fabric.notLearning; }
            set { Fabric.notLearning = value; }
        }

        /// <summary>
        /// characteristics of constituants neurons
        /// determines when spike occurs = state >= treshold
        /// </summary>
        public double Treshold
        {
            get { return treshold; }
            set
            {
                if (value < 0) throw new InvalidOperationException();
                treshold = value;
            }
        }
        private double treshold;

        /// <summary>
        /// What happen to the state when spiking
        /// Spike Effect is applied by multiplying state by this
        /// </summary>
        public double SpikeEffect
        {
            get { return spikeEffect; }
            set
            {
                if (value < 0 || value >= 1) throw new InvalidOperationException(); // No, 1 is not acceptable!
                spikeEffect = value;
            }
        }
        private double spikeEffect;

        /// <summary>
        /// Leaking allows temporal consideration
        /// leaking is applied by multiplying state by leak : 
        /// 1 = no leakage = static state
        /// 0 = total leakage = state lost instantly after frame processing
        /// </summary>
        public double Leak
        {
            get { return leak; }
            set
            {
                if (value < 0 || value > 1) throw new InvalidOperationException();
                leak = value;
            }
        }
        private double leak;

        // internal workset of neurons, may contains neurons from other fabric (inputs)
        private List<SpikingNeuron> neurons;

        // input interfaces
        private Dictionary<string, InputFibre> inputFibres;
        private List<SpikingNeuron> inputs;

        public List<SpikingNeuron> Inputs
        {
            get { return inputs; }
        }


        /// <summary>
        /// Inputs are bound to a set of dedicated neurons to have 
        /// efferent connections in the fabric. These neurons are spiked by their input
        /// </summary>
        /// <param name="input"></param>
        public void connectInputFibre(InputFibre input)
        {
            inputFibres.Add(input.Name, input);

            foreach (SpikingThing st in input.SpikingThings)
            {
                SpikingNeuron sn = new SpikingNeuron(this);
                neurons.Add(sn);
                inputs.Add(sn);
                st.doSpikeMethod = sn.spikeFromExternal;
            }
        }
        public List<SpikingNeuron> getSpikingNeurons()
        {
            return neurons;
        }

        // exposed output workset, generated by learning process
        private List<SpikingNeuron> outputs;

        public List<SpikingNeuron> Outputs
        {
            get { return outputs; }
        }

        List<SpikingNeuron> previouslySpiked;
        List<SpikingNeuron> newlySpiked;

        /// <summary>
        /// Live!
        ///
        /// Cycle through the fabric, put some life in it and return who spiked
        /// </summary>
        /// <returns>Set of neurons who spiked in this slice of life.</returns>
        public void processAndSee()
        {

            previouslySpiked = new List<SpikingNeuron>();
            newlySpiked = new List<SpikingNeuron>();

            // compute state and action lists
            foreach (SpikingNeuron n in neurons)
            {
                if (n.Spiked)
                {
                    // did spike last turn
                    previouslySpiked.Add(n);

                }
                if (n.processAndSee())
                {
                    newlySpiked.Add(n);
                }
            }

            // process efferent synapses
            foreach (SpikingNeuron n in newlySpiked)
            {
                n.spike();
            }


            if ((newlySpiked.Count > 0 || previouslySpiked.Count > 0))
                if (ready) learnTrough();
                else notLearning++;

        }
        private bool ready = true;
        /// <summary>
        /// 
        /// </summary>
        /// <param name="spiked"></param>
        /// <returns></returns>
        public void learnTrough()
        {
            ready = false; // false, if moderation is needed
            if (newlySpiked.Count == 0 && previouslySpiked.Count > 1)
            {
                SpikingNeuron n = new SpikingNeuron(this);
                this.neurons.Add(n);
                this.outputs.Add(n);
                n.updateExitationRelations(previouslySpiked, 1.0);
            }
            foreach (SpikingNeuron n in newlySpiked)
            {
                n.updateConcurrencyRelations(newlySpiked, -1.0);

                n.updateFeedbackRelations(previouslySpiked);
            }
            ready = true;
        }
    }
}
